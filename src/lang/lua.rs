use std::{ffi::OsStr, io::BufWriter};
use std::io::{Write, Read};
use std::fs;
use crate::library::*;
use crate::parse;
use std::path::{Path, PathBuf};
use super::*;
use anyhow::{Result, Context};

// The amount of code/doc we should generate
// Generating full docs for a mock file could be
// a bit to much for a lsp.

// struct LuaDoc {}
pub struct LuaCodegen {
    gir: PathBuf,
    dir: PathBuf,
    dirname: String,
}

// impl LuaCodegen {
    // pub fn new() -> LuaCodegen {
    //     LuaCodegen{}
    // }
// }

// impl Default for LuaCodegen {
//     fn default() -> Self {
//         Self::new()
//     }
// }

impl LuaCodegen {
    fn gen<R: Read>(&self, r: R,  dir: &str, p: &Path) -> Result<()> {
        let repo = parse::parse_gir(r).expect("Couldn't parse gir file");

        repo.namespace[0].gen(dir, p)?;
        Ok(())
    }
}

fn fix_filename(str: &str) -> String {
    str.chars()
    .map(|x| match x { 
        '-' | '.' => '_', 
        _ => x
    }).collect()
}

impl LuaCodegen {
    fn new(filename: &str, output_dir: &str) -> Result<Self> {
        let path = Path::new(filename).to_owned();

        if path.extension() != Some(OsStr::new("gir")) {
            return Err(anyhow::anyhow!(format!("{} Filetype isn't gir", path.to_string_lossy())))
        }
        let file = path.file_stem().ok_or_else(|| 
            anyhow::anyhow!(format!("Cannot get filename for outputwriter")))?;
        let file = fix_filename(file.to_str().ok_or_else(||
            anyhow::anyhow!(format!("Cannot convert filename")))?);

        let output_dir = Path::new(output_dir);

        let output_dir = output_dir.join(&file).join(&file);

        let gir = get_gir(path)?;

        Ok(LuaCodegen { dirname: file, gir, dir: output_dir })
    }

    fn generate(&self, filename: &str) -> Result<()> {
        self.generate_gobject()?;

        let gir_file = open_gir(&self.gir)?;
        let repo = parse::parse_gir(gir_file)?;

        repo.namespace[0].gen(&self.dirname, &self.dir)?;
        Ok(())
    }

    fn generate_gobject<>(&self) -> Result<()> {
        let path = self.dir.join("init.lua");
        let mut w = fs::File::create(path)?;

        writeln!(w, "--- @class GObject.Object")?;
        writeln!(w, "local Object = {{}}")?;

        Ok(())
    }
}

macro_rules! section {
    ( $w:expr, $self:ident, $name:ident, $section:ident ) => {
        {
            if !$self.$section.is_empty() {
                // create_section(&$name, stringify!($section), $w)?;
                for section in $self.$section.iter() {
                    section.gen(&$name, $w)?;
                }
            }
        };
    }
}

fn gen_file(ns: &str, p: &Path) -> Result<BufWriter<File>> {
    let mut path = p.join(ns);
    path.set_extension("lua");
    let mut w = BufWriter::new(fs::File::create(path)?);
    writeln!(w, "---@diagnostic disable: unused-local, duplicate-doc-field")?;
    writeln!(w, "---@meta")?;
    writeln!(w, "-- THIS FILE WAS GENERATED BY gir-to-stub! DO NOT MODIFY!\n")?;
    Ok(w)
}

impl Namespace {
    pub fn gen(&self, dirname: &str, dir: &Path) -> Result<()> {
        let name = self.name.as_ref().context("Failed to read name")?;
        let mut w = gen_file("init", dir)?;
        writeln!(w, "local {} = {{}}\n", name)?;

        for types in self.record.iter() {
            types.gen_type(name, &mut w)?;
        }
        for types in self.callback.iter() {
            types.gen_callback_type(name, &mut w)?;
        }
        for types in self.unions.iter() {
            types.gen_type(name, &mut w)?;
        }
        writeln!(w)?;
        for class in self.classes.iter() {
            writeln!(w, "local _{} = require('{}.{}')", class.name, dirname, class.name)?;
            writeln!(w, "{}.{} = _{}\n", name, class.name, class.name)?;
            class.gen(name, dir)?;
        }
        for record in self.record.iter() {
            if record.name.ends_with("Class") {
                continue;
            }
            writeln!(w, "local _{} = require('{}.{}')", record.name, dirname, record.name)?;
            writeln!(w, "{}.{} = _{}\n", name, record.name, record.name)?;
            record.gen(name, dir)?;
        }
        // section!(&mut w, self, name, record);

        section!(&mut w, self, name, enums);
        section!(&mut w, self, name, bitfield);

        for function in self.functions.iter() {
            function.gen(name, name, &mut w)?;
        }

        section!(&mut w, self, name, constant);
        section!(&mut w, self, name, alias);
        section!(&mut w, self, name, unions);
        writeln!(&mut w, "return {}", name)?;
        w.flush()?;
        Ok(())
    }
}

impl Alias {
    pub fn gen<W: Write>(&self, ns: &str, w: &mut W) -> Result<()> {
        writeln!(w, "--- @alias {}.{} {}", ns, &self.name, show_anytyp(&self.typ, ns))?;
        Ok(())
    }
}

fn gen_default_construtor<W:Write>(ns: &str, constrs: &[Function], w: &mut W) -> Result<()> {
    for constr in constrs {
        if constr.name == "new" {
            if let Some(ret) = gen_return_names_typed(constr, ns) {
                writeln!(w, "--- @overload fun(params: {{}}):{}", ret)?;
            }
            return Ok(())
        }
    }
    Ok(())
}

macro_rules! introspectable {
    ($id:ident) => {
        if let Some(false) = $id.info.introspectable {
            return Ok(())
        }
    };
}

impl Class {
    pub fn gen_type<W: Write>(&self, ns: &str, w: &mut W) -> Result<()> {
        introspectable!(self);
        self.info.gen(w)?;
        if let Some(ref parent) = self.parent {
            writeln!(w, "--- @class {}.{} : {}", ns, self.name, translate_ns(parent, ns))?;
        } else {
            writeln!(w, "--- @class {}.{}", ns, self.name)?;
        }
        section!(w, self, ns, signals);
        section!(w, self, ns, fields);
        section!(w, self, ns, properties);
        gen_default_construtor(ns, &self.constructor, w)?;
        writeln!(w, "local {} = {{}}", self.name)?;
        Ok(())
    }
    pub fn gen(&self, ns: &str, p: &Path) -> Result<()> {
        introspectable!(self);
        let mut w = gen_file(&self.name, p)?;

        self.gen_type(ns, &mut w)?;

        // let class_ns = &self.name;

        // section!(&mut w, self, self.name, implements);

        for constructor in self.constructor.iter() {
            constructor.gen(&self.name, ns, &mut w)?;
        }
        for method in self.method.iter() {
            method.gen(&self.name, ns, &mut w)?;
        }
        for func in self.functions.iter() {
            func.gen(&self.name, ns, &mut w)?;
        }
        // TODO: Should we re-add this in some way?

        // if !self.virtual_method.is_empty() {
        //     for virt in self.virtual_method.iter() {
        //         virt.gen_method(&self.name, ns, &mut w)?;
        //     }
        // }
        for callback in self.callbacks.iter() {
            callback.gen(&self.name, ns, &mut w)?;
        }

        // section!(&mut w, self, self.name, record);
        // section!(&mut w, self, self.name, unions);
        // section!(&mut w, self, self.name, constant);

        writeln!(w, "--- @param obj GObject.Object")?;
        writeln!(w, "--- @return boolean")?;
        writeln!(w, "function {}:is_type_of(obj) end", self.name)?;

        writeln!(w, "return {}", &self.name)?;
        w.flush()?;

        Ok(())
    }
}

//
// impl Implement {
//     pub fn gen<W: Write>(&self, _ns: &str, w: &mut W) -> Result<()> {
//         Ok(writeln!(w, "-- implements: {}", self.name)?)
//     }
// }

impl Union {
    pub fn gen_type<W: Write>(&self, ns: &str, w: &mut W) -> Result<()> {
        introspectable!(self);

        if let Some(ref name) = self.name {
            writeln!(w, "--- @class {}.{}", ns, name)?;
            section!(w, self, ns, fields);
            writeln!(w, "local {} = {{}}", name)?;
        }
        Ok(())
    }
    /// this is like a record (but not), we should generate it the same way
    pub fn gen<W: Write>(&self, ns: &str, w: &mut W) -> Result<()> {
        introspectable!(self);
        if let Some(false) = self.info.introspectable {
            return Ok(())
        }
        if let Some(ref name) = self.name {
            let union_ns = format!("{}.{}", ns, name);

            for constructor in self.constructor.iter() {
                constructor.gen(&union_ns, ns, w)?;
            }
            for method in self.method.iter() {
                method.gen(&union_ns, ns, w)?;
            }
        }

        Ok(())
    }
}

impl Field {
    pub fn gen<W: Write>(&self, ns: &str, w: &mut W) -> Result<()> {
        if !self.private {
            let typ = show_anytyp(&self.typ, ns);
            writeln!(w, "--- @field {} {}", self.name, typ)?;
        }
        Ok(())
    }
}

impl Property {
    pub fn gen<W: Write>(&self, ns: &str, w: &mut W) -> Result<()> {
        let typ = show_anytyp(&self.typ, ns);
        Ok(writeln!(w, "--- @field {} {}", self.name.replace('-', "_"), typ)?)
    }
}

fn gen_return_signal(fun: &Signal, ns: &str) -> Option<String> {
    let mut params = vec![];

    if let Some(ref p) = fun.ret {
        params.push(p)
    }

    for p in fun.parameters.iter().filter(|p| out_param(&p.direction)) {
        params.push(p)
    }

    if params.is_empty() {
        return None
    }

    let param_names: Vec<String> = params
        .iter()
        .map(|p| show_anytyp(&p.typ, ns))
        .collect();
    Some(param_names.join(", "))
}

fn signal_name(str: &str) -> String {
    format!("on_{}", str.replace('-', "_"))
}

impl Signal {
    pub fn gen<W: Write>(&self, ns: &str, w: &mut W) -> Result<()> {
        introspectable!(self);
        let mut param_names = gen_param_names_typed(&self.parameters, ns);
        param_names.insert(0, "self".to_string());
        let param_names = param_names.join(", ");
        let name = signal_name(&self.name);
        if let Some(ret) = gen_return_signal(self, ns) {
            writeln!(w, "--- @field {} fun({}):{}", name, param_names, ret)?;
        } else {
            writeln!(w, "--- @field {} fun({})", name, param_names)?;
        }
        Ok(())
    }
}

const KEYWORDS: &'static [&'static str] = &[
    "and",       "break",     "do",        "else",      "elseif",
    "end",       "false",     "for",       "function",  "if",
    "in",        "local",     "nil",       "not",       "or",
    "repeat",    "return",    "then",      "true",      "until",     "while",
];

pub fn unkeyword(param_name: &str) -> String {
    for key in KEYWORDS.iter() {
        if *key == param_name {
            return format!("{}_", key);
        }
    }
    param_name.to_owned()
}

fn show_anytyp(typ: &AnyType, ns: &str) -> String {
    match typ {
        AnyType::Array(array) => {
            let typ = array.typ.clone();
            if let Some(name) = &array.name {
                if name == "GLib.ByteArray" && typ == "guint8" {
                    "string".to_string()
                } else {
                    let mut array = translate(&typ, ns);
                    array.push_str("[]");
                    array
                }
            } else {
                if typ == "guint8" {
                    return "string".to_string()
                }
                let typ = array.typ.clone();
                let mut array = translate(&typ, ns);
                array.push_str("[]");
                array
            }
        },
        AnyType::Type(typ) => {
            if let Some(name) = &typ.name {
                match name.as_ref() {
                    "GLib.SList" | "GLib.List" => 
                        format!("{}[]", show_anytyp(&typ.children[0], ns)),
                    "GLib.HashTable" => {
                        let key = show_anytyp(&typ.children[0], ns);
                        let value = show_anytyp(&typ.children[1], ns);
                        format!("table<{}, {}>", key, value)
                    },
                    _ => translate(name, ns),
                }
            } else {
                "any".to_string()
            }
        }
        AnyType::VarArg => "...".to_owned(),
    }
}

// todo we should just remove const etc from the type
fn translate(name: &str, ns: &str) -> String {
    match name {
        "gboolean" => "boolean".to_string(),
        "gpointer" => "any".to_string(),
        "GType" => "Glib.GType".to_string(),
        "gint" | "guint" 
            | "gint8" | "guint8"
            | "gint16" | "guint16"
            | "gint32" | "guint32"
            | "gint64" | "guint64"
            | "gsize" | "gssize" => "number".to_string(),
            "glong"| "gulong"
                | "glong64"| "gulong64"
                | "gshort"| "gushort"
                | "gshort64"| "gushort64"
                | "gfloat"| "gdouble" => "number".to_string(),
                "const char*"|"char*"
                    | "gchar" | "guchar"
                    | "string" | "GString"
                    | "utf8" => "string".to_string(),
                "none" => "nil".to_string(),
                rest => {
                    translate_ns(rest, ns)
                }
    }
}

fn translate_ns(name: &str, ns: &str) -> String {
    if !name.contains('.') {
        return format!("{}.{}", ns, name)
    }
    name.to_string()
}

impl InfoAttrs {
    fn gen<W: Write>(&self, w: &mut W) -> Result<()> {
        if let Some(true) = self.deprecated {
            writeln!(w, "--- @deprecated")?;
        }
        Ok(())
    }
}

impl InfoElements {
    fn gen<W: Write>(&self, w: &mut W) -> Result<()> {
        if let Some(ref docs) = self.doc {
            let luafied = docs.content.replace("%NULL", "nil");
            let lines = luafied.split('\n');
            for line in lines {
                writeln!(w, "--- {}", line)?;
            }
        }
        // if let Some(ref stability) = doc.doc_stability {
        // }
        // if let Some(ref version) = doc.doc_version {
        // }
        // if let Some(ref deprecated) = doc.doc_deprecated {
        // }
        // if let Some(ref pos) = doc.doc_pos {
        // }
        Ok(())
    }
}

fn optional(param: &Parameter) -> &str {
    if param.optional || param.allow_none {
        return "?"
    }
    ""
}

impl Parameter {
    fn gen<W: Write>(&self, ns: &str, w: &mut W) -> Result<()> {
        let type_str = show_anytyp(&self.typ, ns);
        let opt = optional(self);
        if let Some(ref doc) = self.doc.doc {
            let luafied = doc.content.replace("%NULL", "nil");
            let docstr = luafied.replace('\n', "");
            writeln!(w, "--- @param {} {}{} {}", unkeyword(&self.name), type_str, opt, docstr)?;
        } else {
            writeln!(w, "--- @param {} {}{}", unkeyword(&self.name), opt, type_str)?;
        }
        Ok(())
    }
}

fn gen_doc_params<W: Write>(params: &[Parameter], ns: &str, skip: bool, w: &mut W) -> Result<()> {
    let mut num = 0;
    if skip {
        num = 1;
    }
    for param in params.iter().skip(num).filter(|p| in_param(&p.direction)) {
        param.gen(ns,w)?;
    }
    Ok(())
}

fn gen_doc_return<W: Write>(fun: &Function, ns: &str, w: &mut W) -> Result<Option<String>> {
    let mut params = vec![];

    if let Some(ref p) = fun.ret {
        params.push(p)
    }

    for p in fun.parameters.iter().filter(|p| out_param(&p.direction)) {
        params.push(p)
    }
    if !params.is_empty() {
        let mut rets = vec![];
        for param in params.iter() {
            let mut type_str = show_anytyp(&param.typ, ns);
            if type_str != "nil" {
                if param.nullable {
                    type_str = format!("{}|nil", type_str);
                }
                rets.push(type_str);
            }
        }
        if !rets.is_empty() {
            let retlist = rets.join(", ");
            return Ok(Some(retlist));
            // writeln!(w, "--- @return {}", retlist)?;
        }
    }
    Ok(None)
}

fn in_param(direction: &Option<ParameterDirection>) -> bool {
    if let Some(direct) = direction {
        return matches!(direct, ParameterDirection::In | ParameterDirection::InOut);
    }
    true
}

fn out_param(direction: &Option<ParameterDirection>) -> bool {
    if let Some(direct) = direction {
        return matches!(direct, ParameterDirection::Out | ParameterDirection::InOut);
    }
    false
}

fn gen_param_names(params: &[Parameter], skip: bool) -> String {
    let mut num = 0;
    if skip {
        num = 1;
    }
    let param_names: Vec<String> = params
        .iter()
        .skip(num)
        .filter(|p| in_param(&p.direction))
        .map(|p| unkeyword(&p.name))
        .collect();
    param_names.join(", ")
}

fn gen_param_names_typed(params: &[Parameter], ns: &str) -> Vec<String> {
    params
        .iter()
        .filter(|p| in_param(&p.direction))
        .map(|p| format!("{}: {}", unkeyword(&p.name), show_anytyp(&p.typ, ns)))
        .collect()
}

fn gen_return_names_typed(fun: &Function, ns: &str) -> Option<String> {
    let mut params = vec![];

    if let Some(ref p) = fun.ret {
        params.push(p)
    }

    for p in fun.parameters.iter().filter(|p| out_param(&p.direction)) {
        params.push(p)
    }

    if params.is_empty() {
        return None
    }

    let param_names: Vec<String> = params
        .iter()
        .map(|p| show_anytyp(&p.typ, ns))
        .collect();
    Some(param_names.join(", "))
}

impl Function {
    pub fn gen<W: Write>(&self, ns: &str, root_ns: &str, w: &mut W) -> Result<()> {
        introspectable!(self);
        self.info.gen(w)?;
        self.doc.gen(w)?;
        let skip = self.typ == FunctionType::Method;
        gen_doc_params(&self.parameters, root_ns, skip, w)?;
        let ret = gen_doc_return(self, root_ns,  w)?;
        let param_names = gen_param_names(&self.parameters, skip);
        match self.typ {
            FunctionType::Callback => panic!("Use gen_callback for callbacks!"),
            FunctionType::Method => {
                if let Some(ret) = ret {
                    writeln!(w, "--- @return {}", ret)?;
                }
                writeln!(w, "function {}:{}({}) end\n", &ns, self.name, param_names)?
            },
            FunctionType::Virtual => todo!(),
            FunctionType::Member => {
                if let Some(ret) = ret {
                    writeln!(w, "--- @return {}", ret)?;
                }
                writeln!(w, "\t[\"{}\"] = function({}) end,\n",
                    self.name.to_uppercase(), param_names)?
            }
            FunctionType::Function => {
                if let Some(ret) = ret {
                    writeln!(w, "--- @return {}", ret)?;
                }
                writeln!(w, "function {}.{}({}) end\n", &ns, self.name, param_names)?
            }
            FunctionType::Constructor => {
                writeln!(w, "--- @return {}.{}", root_ns, ns)?;
                writeln!(w, "function {}.{}({}) end\n", &ns, self.name, param_names)?;
            },
        }
        Ok(())
    }
    pub fn gen_callback_type<W: Write>(&self, ns: &str, w: &mut W) -> Result<()> {
        introspectable!(self);
        let param_names = gen_param_names_typed(&self.parameters, ns).join(", ");
        if let Some(ret) = gen_return_names_typed(self, ns) {
            writeln!(w, "--- @alias {}.{} fun({}):{}", ns, self.name, param_names, ret)?;
        } else {
            writeln!(w, "--- @alias {}.{} fun({})", ns, self.name, param_names)?;
        }
        Ok(())
    }
}

impl Member {
    pub fn gen<W: Write>(&self, w: &mut W) -> Result<()> {
        introspectable!(self);
        Ok(writeln!(w, "\t[\"{}\"] = {},", self.name.to_uppercase(), self.value)?)
    }
}

impl Record {
    pub fn gen_type<W: Write>(&self, ns: &str, w: &mut W) -> Result<()> {
        introspectable!(self);
        // Skip these
        if self.name.ends_with("Class") {
            return Ok(())
        }

        if let Some(false) = self.info.introspectable {
            return Ok(())
        }

        writeln!(w, "--- @class {}.{}", ns, self.name)?;
        section!(w, self, ns, fields);
        Ok(writeln!(w, "local {} = {{}}", self.name)?)
    }
    pub fn gen(&self, ns: &str, p: &Path) -> Result<()> {
    // pub fn gen<W: Write>(&self, ns: &str, w: &mut W) -> Result<()> {
        introspectable!(self);
        if let Some(false) = self.info.introspectable {
            return Ok(())
        }

        let mut w = gen_file(&self.name, p)?;

        let record_ns = format!("{}.{}", ns, self.name);

        for constructor in self.constructor.iter() {
            constructor.gen(&record_ns, ns, &mut w)?;
        }
        for method in self.method.iter() {
            method.gen(&record_ns, ns, &mut w)?;
        }
        for func in self.functions.iter() {
            func.gen(&record_ns, ns, &mut w)?;
        }

        for unio in self.unions.iter() {
            unio.gen(&record_ns, &mut w)?;
        }
        Ok(())
    }
}

impl Constant {
    pub fn gen<W: Write>(&self, ns: &str, w: &mut W) -> Result<()> {
        introspectable!(self);
        if self.value.parse::<u32>().is_ok() {
            Ok(writeln!(w, "{}.{} = {}", ns, self.name, self.value)?)
        } else {
            Ok(writeln!(w, "{}.{} = \"{}\"", ns, self.name, self.value)?)
        }
    }
}

impl Enumeration {
    pub fn gen<W: Write>(&self, ns: &str, w: &mut W) -> Result<()> {
        introspectable!(self);
        writeln!(w, "--- @enum {}.{}", &ns, self.name)?;
        writeln!(w, "{}.{} = {{", &ns, self.name)?;
        for mem in self.members.iter() {
            mem.gen(w)?;
        }
        for func in self.functions.iter() {
            func.gen("", ns, w)?;
        }
        Ok(writeln!(w, "}}")?)
    }
}

impl Bitfield {
    pub fn gen<W: Write>(&self, ns: &str, w: &mut W) -> Result<()> {
        introspectable!(self);
        writeln!(w, "--- @enum {}.{}", &ns, self.name)?;
        writeln!(w, "--- @overload fun({{any}}): {}.{}", &ns, self.name)?;
        writeln!(w, "{}.{} = {{", &ns, self.name)?;
        for mem in self.members.iter() {
            mem.gen(w)?;
        }
        for func in self.functions.iter() {
            func.gen("", ns, w)?;
        }
        writeln!(w, "}}", )?;
        Ok(())
    }
}
